[{"content":"As a CloudOps Engineer one key skill is automating repetitive tasks. What most people grab for intuitively is writing Shell scripts (be it Bash, zsh, fish or whichever flavor you prefer). And there are a lot many good reasons to do so:\n It is closest to typing commands directly in the terminal. You don\u0026rsquo;t have to learn a dedicated programming language. It is very portable to other platforms like e.g. a CI server.  But once you start managing an increasing number of tasks with your scripts, you start to face another problem: How do you manage your scripts?\nPersonally, I have always loved being able to enter some new place where conventions were already in place. It takes away so much work and mental effort at the beginning, and you can just get to work quickly. (That might explain why I fell in love with ❤️ Ruby on Rails before I dug into 💎 Ruby.)\nShell scripts by their very nature do not pose any restrictions regarding e.g. naming patterns or directory structures. Honestly, I think there never will be, and that is ok. But what I have come to appreciate a lot recently is Make as a companion for my Shell scripts.\n🏗 Make vs. 🐚 Shell in a 🥜 Nutshell  Purpose: Make is good at creating files, Shell is good at executing scripts. Portability: If your system has Bash, chances are pretty high that Make is also available. Developer API: Make has a clear entrypoint (namely make), Shell can be everything you want it to be.  Make is a tool that has its origin in the world of compiled languages, especially C. Compiling source code into binary artifacts (and doing so 🏎 economically) is what Make was originally designed for. I mean, the name of a tool should make its use clear, but let me just state this again for my future self: Make is meant to 🏗 make (create) files.\nIt\u0026rsquo;s all about target files. That\u0026rsquo;s why it makes sense to approach a Makefile with a mindset of \u0026ldquo;What do I want to create/build?\u0026rdquo; instead of \u0026ldquo;What do I want to perform?\u0026rdquo; To me this sounds very reminiscent of the distinction between declarative and imperative programming.\nSafely Versioned Secrets Management My concrete entrypoint into Make was the following use case I had lately, and it hopefully helps to illustrate the point of target files:\n ☸️ You have 2 AWS accounts with 1 Kubernetes cluster each. (One is for running a dev and a staging environment, the other one is running the production environment.) 🔑 Secrets are stored in AWS Secrets Manager and synced into the cluster via ExternalSecrets. ⛔️ You are not allowed to store secrets in Git, not even in encrypted form. 🪣 The secrets are JSON files and the key names are important, so you want to store them in Git.  What I did as a first step was to create sample secrets files that contained the keys but no valid data (kind of the schema of the secrets):\nsecrets ├── dev # One directory per target environment │ └── .keep ├── staging │ └── .keep ├── prod │ └── .keep ├── config1.sample.json # One sample file per secret ├── service2.sample.json └── service3.sample.json I put the keys I needed into the sample files and as a value a description of what to put in (or e.g. from which Password Service to fetch the value from). The file service2.sample.json would e.g. look like this.\n{ \u0026#34;EXTERNAL_API_KEY\u0026#34;: \u0026#34;API Key of EXTERNAL_SERVICE\u0026#34;, \u0026#34;CLOUD_SERVICE_CLIENT_SECRET\u0026#34;: \u0026#34;client secret for accessing CLOUD_SERVICE\u0026#34;, \u0026#34;CLOUD_SERVICE_PASSWORD\u0026#34;: \u0026#34;password for accessing CLOUD_SERVICE\u0026#34;, \u0026#34;BASIC_AUTH_PASSWORD\u0026#34;: \u0026#34;password for sending via Basic Auth\u0026#34; } The target structure I wanted to achieve was this:\nsecrets ├── dev │ ├── config1.json # This file contains the *keys* of │ │ # secrets/config1.sample.json │ │ # and the actual secret *values*! │ ├── service2.json │ ├── service3.json │ └── .keep ├── staging │ ├── config1.json # Contains key of sample file and │ │ # values for staging environment. │ ├── service2.json │ ├── service3.json │ └── .keep ├── prod │ ├── config1.json │ ├── service2.json │ ├── service3.json │ └── .keep ├── config1.sample.json ├── service2.sample.json └── service3.sample.json In order to not commit any actual secrets into version control, I added the following entries to my .gitignore:\n# Ignore secret data ... secrets/**/*.json # ... but keep the samples !secrets/*.sample.json Copying the Samples Now how do you copy the files to all environment\u0026rsquo;s directories? And how do you make sure you copy them exactly once (so you don\u0026rsquo;t lose the secrets you already entered)?\nYou could create a script with the following logic:\n# For each environment directory: ## For each sample file: ### Extract the service name ### Check if target secret file already exists ### If not, copy sample to target file But now, 🏗 Make to the rescue:\n### Variables  # Fetch all sample files. secrets_samples := $(wildcard secrets/*.sample.json) # Construct the paths for all dev secrets destinations. dev_secrets := $(patsubst secrets/%.sample.json,secrets/dev/%.json,$(secrets_samples)) # Construct the paths for all staging secrets destinations. staging_secrets := $(patsubst secrets/dev/%,secrets/staging/%,$(dev_secrets)) # Construct the paths for all staging secrets destinations. prod_secrets := $(patsubst secrets/dev/%,secrets/prod/%,$(dev_secrets)) # Gather the paths of all secrets\u0026#39; destinations. all_secrets := $(dev_secrets) $(staging_secrets) $(prod_secrets) ### Rules  # 🎯 Purpose: \u0026#34;Copy all samples to their destinations.\u0026#34; # 🤓 What Make sees: \u0026#34;When you build the file secrets.copy-templates, # make sure that all files in $(all_secrets) have been built first.\u0026#34; # 👩‍🏫 Explanation: A rule can be empty, and a rule can have prerequisites # on the first line. I like to think of such a rule as a kind of shortcut. secrets.copy-templates: $(all_secrets) # 🎯 Purpose: \u0026#34;Ensure that Make still runs the job \u0026#39;secrets.copy-templates\u0026#39; # even if a file called \u0026#39;secrets.copy-templates\u0026#39; is created.\u0026#34; # 🤓 What Make sees: \u0026#34;I am supposed to always build secrets.copy-templates # even if that file already exists.\u0026#34; .PHONY: secrets.copy-templates # 🎯 Purpose: \u0026#34;Copy the file on the right to the file on the left.\u0026#34; # 🤓 What Make sees: \u0026#34;When a file matching the pattern secrets/dev/(.*).json # is built, execute this rule. # Also first make sure that the corresponding file secrets/$1.sample.json # has been built before. # And the rule is: Copy the source file on the right ($\u0026lt;) to the destination # file on the left ($@).\u0026#34; # 👩‍🏫 Explanation: These 3 rules are applied when you call secrets.copy-templates # because it requires $(all_secrets) to be built. secrets/dev/%.json: secrets/%.sample.json cp $\u0026lt; $@ secrets/staging/%.json: secrets/%.sample.json cp $\u0026lt; $@ secrets/prod/%.json: secrets/%.sample.json cp $\u0026lt; $@ If you now execute make secrets.copy-templates, the sample files will be copied to all environment directories. And if you run that same command again, 🙊 Make will not copy anything because it intelligenty detected that the source files have not changed since the last execution.\nThe code above is certainly not optimal - I bet you could abstract away the environment names with bit of metaprogramming, but let\u0026rsquo;s not optimize prematurely. I think the result is already impressive, especially if you consider the following:\n ☝️ You don\u0026rsquo;t even have to call the job explicitly to run it. As long as secrets.copy-templates is the first build defined in the Makefile, you can even execute just make without any parameters. 👨‍💻 Onboarding a new colleague to your repository now sounds a lot more like: \u0026ldquo;Yes, do read the README, but above all execute make.\u0026rdquo;  ⛑ This is especially true if your Makefile contains good help texts for every rule.    How Not To Shoot Yourself in the Foot Make was made primarily for building binaries from source code. The fact that we are able to use it in the way described above comes with a warning: If you do the following, you will lose the secret data you already entered into the secret files:\n Execute make secrets.copy-templates. Edit a sample file. Execute make secrets.copy-templates. 💥 Make will copy and overwrite the edited sample file to all environment secret files.  Why? Make compares timestamps, and when the source has a newer last-modified timestamp than the destination it will execute the rule\nCan we circumvent this? We sure can. You can either make sure that you edit each environment file after editing the sample file. Or you change the last-modified timestamp via a build in the Makefile 😉:\nsecrets.ensure-copy-once: for f in $(all_secrets); do [ -f $$f ] \u0026amp;\u0026amp; touch $$f; done Now whenever you edit a sample file after the initial secrets.copy-templates you run this build via make secrets.ensure-copy-once and 🛡 your secrets will not be deleted.\nExtension: Environment-specific Sample Files One implicit assumption in my structure was that the secrets in service2 will always have the same schema in every environment. One day it so happened that service2 needed to have additional keys on prod, but they should not be present on dev or staging.\nI adjusted my desired structure like this:\nsecrets ├── dev │ ├── config1.json │ ├── service2.json # Contains keys from service2.sample.json │ ├── service3.json │ └── .keep ├── staging │ ├── config1.json │ ├── service2.json # Contains keys from service2.sample.json │ ├── service3.json │ └── .keep ├── prod │ ├── config1.json │ ├── service2.json # Contains keys from service2.sample.prod.json │ ├── service3.json │ └── .keep ├── config1.sample.json ├── service2.sample.json # Default sample file ├── service2.sample.prod.json # Prod-specific sample file └── service3.sample.json And I wrote my first Makefile function:\n# A Make function can take in an arbitrary number of numbered parameters. define copy_template cp $(1) $(2) @# Check if there is a more environment-specific sample file \t$(eval ENVIRONMENT := $(shell echo $(2) | sed -E \u0026#39;s#secrets/(.*)/.*#\\1#\u0026#39;)) $(eval ENVIRONMENT_SAMPLE_FILE := $(patsubst %.sample.json,%.sample.$(ENVIRONMENT).json,$(1))) @# If environment-specific file exists, copy it to destination if [ -f \u0026#34;$(ENVIRONMENT_SAMPLE_FILE)\u0026#34; ]; then cp $(ENVIRONMENT_SAMPLE_FILE) $(2); fi endef # Calling a Make function works by executing \u0026#39;call\u0026#39; # with the function name and all its parameters as a list. # My previous rules now became this: secrets/dev/%.json: secrets/%.sample.json $(call copy_template,$\u0026lt;,$@) secrets/staging/%.json: secrets/%.sample.json $(call copy_template,$\u0026lt;,$@) secrets/prod/%.json: secrets/%.sample.json $(call copy_template,$\u0026lt;,$@) 🍣 Perfect Symphony: Calling Scripts From Make It\u0026rsquo;s all good and nice to have your secrets created, but how do you deploy them to AWS Secrets Manager? Of course you write a thin wrapper around the wonderfully verbose AWS CLI:\n#!/usr/bin/env bash set -euo pipefail # set -x # DEBUG secret_name=\u0026#34;$1\u0026#34; # Use second argument or read stdin secret_value=\u0026#34;${2:-$(cat -)}\u0026#34; echo \u0026#34;$secret_value\u0026#34; # DEBUG # Create secret in idempotent way, avoid script from failing set +e aws secretsmanager create-secret --name \u0026#34;$secret_name\u0026#34; \u0026amp;\u0026gt; /dev/null set -e # Put secret value and output response to stdout aws secretsmanager put-secret-value --secret-id \u0026#34;$secret_name\u0026#34; \\  --secret-string \u0026#34;$secret_value\u0026#34; | cat In your terminal you would call it e.g. like this:\n./helpers/deploy-secret.sh envs/dev/config1-secrets \u0026lt; secrets/dev/config1.json\nLet\u0026rsquo;s make a generic rule in Make to execute this script:\n# The dependency on $(all_secrets) is to make sure that the secrets files exist # before deploying them. secret.deploy: $(all_secrets) ./helpers/deploy-secret.sh $(name) \u0026lt; secrets/$(environment)/$(filename) The call to the script that you executed above would become this:\nmake secret.deploy name=envs/dev/config1-secrets environment=dev filename=config1\nAs we have multiple services, let\u0026rsquo;s add one rule per service:\n# The secret values in this one are the same across all environments secret.deploy.config1: $(MAKE) secret.deploy name=envs/config1-secrets filename=config1.json # service2 has different secret values on the different environments secret.deploy.service2: $(MAKE) secret.deploy name=envs/$(environment)/service2-secrets filename=service2.json # service 3 also has environment-specific secret values secret.deploy.service3: $(MAKE) secret.deploy name=envs/$(environment)/service3-secrets filename=service3.json Now we can tie these together into one rule for a whole environment:\n# Deploy all secrets for one environment secrets.deploy.all: $(MAKE) secret.deploy.config1 $(MAKE) secret.deploy.service2 $(MAKE) secret.deploy.service3 # Deploy all secrets for the dev cluster secrets.deploy.dev: $(MAKE) secrets.deploy.all environment=dev $(MAKE) secrets.deploy.all environment=staging # Deploy all secrets for the prod cluster secrets.deploy.prod: $(MAKE) secrets.deploy.all environment=prod ✅ Once you are authenticated to the corresponding AWS account, you can deploy your secrets with either make secrets.deploy.dev or make secrets.deploy.prod.\nSummarizing  Make gives you a consistent and clean Developer API. Make is almost universally installed everywhere. Don\u0026rsquo;t decide between either Make or Shell - use both together. Refactor more complex logic into separate Shell scripts (like isolated functions) which are called from within Make.  You can check out the entire Makefile (including the secrets structure and scripts) in this Git repo.\nCredits I am indebted to the following parties in making my start into the world of Make a lot smoother than I expected:\n Isaac Z. Schlueter for his interactive Gist The guys at Upbound for creating Crossplane where they use Make in their providers and even distribute common functionality as a Git submodule  ","date":"2021-09-06T13:38:15+02:00","permalink":"https://jscheytt.github.io/p/the-story-of-my-first-makefile-half-versioned-secrets-management/","title":"The Story of My First Makefile — Half-Versioned Secrets Management"},{"content":"HTML allows you to specify a starting number from which an ordered list (\u0026lt;ol\u0026gt;) should start. I thought \u0026ldquo;Is there an upper bound?\u0026rdquo;.\nTurns out: Yes, there is. It\u0026rsquo;s 2147483647 (i.e. 231-1 ). Looks like a signed 32-bit integer to me.\n\u0026lt;ol start=2147483645\u0026gt; \u0026lt;li\u0026gt;I am still in order\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;As am I\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Me too\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;💥 Limit reached\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;💥 Limit reached\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;💥 Limit reached\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; The above snippet will render as the following:\n I am still in order As am I Me too 💥 Limit reached 💥 Limit reached 💥 Limit reached   ","date":"2021-09-02T08:55:22+02:00","permalink":"https://jscheytt.github.io/p/html-limits-you-to-a-signed-32-bit-int-in-ordered-lists/","title":"HTML limits you to a signed 32-bit int in ordered lists"},{"content":"All you need is the secret of your TOTP.\nThe QR code is just a representation of a oath:// URL That URL contains the secret as a query parameter.\n# Install oathtool brew install oathtool # Use your secret, e.g. as a base32-encoded string oathtool --totp --base32 \u0026#34;MFRGCZDTMVRXEZLUBI======\u0026#34; ","date":"2021-08-27T08:20:41+02:00","permalink":"https://jscheytt.github.io/p/you-can-create-totp-tokens-via-cli-without-a-smartphone/","title":"You can create TOTP tokens via CLI without a smartphone"},{"content":"I really love Docker, and I also come to like security more and more. One advice I have been hearing a lot (e.g. in this Container Security Cheat Sheet from Snyk) is that you should not run your container as a root user.\n\u0026ldquo;Easy thing,\u0026rdquo; I thought to myself, \u0026ldquo;I am just going to put something like USER {app}\u0026rdquo; at the top of my Dockerfile.\u0026quot; Well, think again, because:\nFROMnode:ltsUSERnode# I would have thought that after this point, every action will happen in the name of this user# and also that every created directory and file will belong to this user ... 😕 But:# ⚠️ This directory is created by root:root!WORKDIR/app# ⚠️ These files will be copied over to be owned by root:root!COPY package*.json ./# 💥 This step fails in some (not all!) environments with errors like \u0026#34;Not enough permissions on /app\u0026#34;RUN npm install \u0026amp;\u0026amp; \\  npm run verify# ⚠️ If you manage to get to this point, these files, too, will be copied over to be owned by root:root!COPY . .ENTRYPOINT [\u0026#34;npm\u0026#34;]I ended up fixing it by creating the directory and then chown-ing it. Equally I executed the COPY instructions with the --chown flag. In the end I refactored it a bit using some ENVs, too:\nFROMnode:lts# Ensure that target WORKDIR exists and is owned by target (non-root) userENV USERNAME=node ENV USERID=$USERNAME:$USERNAMEENV TARGETDIR=/appRUN mkdir -p $TARGETDIR \u0026amp;\u0026amp; chown -R $USERID $TARGETDIRWORKDIR$TARGETDIRUSER$USERNAMECOPY --chown=$USERID package*.json ./RUN npm install \u0026amp;\u0026amp; \\  npm run verifyCOPY --chown=$USERID . .ENTRYPOINT [\u0026#34;npm\u0026#34;]","date":"2021-07-23T14:42:07+02:00","permalink":"https://jscheytt.github.io/p/docker-does-not-really-help-you-a-lot-trying-to-get-permissions-right/","title":"Docker does not really help you a lot trying to get permissions right"},{"content":"I have developed quite some muscle memory in terminating vim via :wqa. Now I can save one more character by retraining myself to use :xa! 😄\nI also like how :x sort of symbolizes the close button ❌ of many window managers and their default behavior of saving when you close a file.\nFor more documentation open vim and type :h :x.\nWait, now that you mention it \u0026hellip; Well, turns out the documentation mentions an even easier way: Just press ZZ (without the colon) 😴\nNow if only I could combine this to perform :wqa \u0026hellip;\nHappy vim-ing! 👋\n","date":"2021-07-16T00:00:00Z","permalink":"https://jscheytt.github.io/p/you-can-wq-in-vim-with-x/","title":"You can :wq in vim with :x"}]