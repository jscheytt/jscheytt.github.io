<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Git on Josia's Blog</title><link>https://jscheytt.github.io/tags/git/</link><description>Recent content in Git on Josia's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Josia Scheytt</copyright><lastBuildDate>Mon, 28 Feb 2022 13:15:29 +0100</lastBuildDate><atom:link href="https://jscheytt.github.io/tags/git/index.xml" rel="self" type="application/rss+xml"/><item><title>The Git Commands You Wish You Always Had</title><link>https://jscheytt.github.io/p/the-git-commands-you-wish-you-always-had/</link><pubDate>Mon, 28 Feb 2022 13:15:29 +0100</pubDate><guid>https://jscheytt.github.io/p/the-git-commands-you-wish-you-always-had/</guid><description>&lt;p&gt;Recently I wanted to do a bulk cleanup on some GitHub repositories I am responsible for, deleting old branches that have already been merged into the default branches.
I first considered performing it through the GitHub API, but then I decided to try doing it via Git itself.&lt;/p&gt;
&lt;p&gt;After I had begun dabbling with a few wrapper scripts, I suddenly remembered something which massively simplified my strategy:
&lt;strong&gt;Git Aliases&lt;/strong&gt;.
These are Git commands you can define yourself, either via CLI or in the Gitconfig file.&lt;/p&gt;
&lt;p&gt;With this article, I want to introduce what I learned about Git aliases â€“ and in the process, you get all the aliases I defined for my cleanup ðŸ˜‰&lt;/p&gt;
&lt;h2 id="defining-shortcuts"&gt;Defining Shortcuts
&lt;/h2&gt;&lt;p&gt;Many articles about Git aliases explain only the &lt;strong&gt;shortcut side&lt;/strong&gt;.
They show e.g. how you can abbreviate &lt;code&gt;git checkout&lt;/code&gt; to &lt;code&gt;git co&lt;/code&gt; by running &lt;code&gt;git config --global alias.co checkout&lt;/code&gt;.
Alternatively to the CLI command, you can add this section to your &lt;code&gt;~/.gitconfig&lt;/code&gt; file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-ini" data-lang="ini"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;[alias]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;co&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;checkout&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nowadays, with the &lt;a class="link" href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git" target="_blank" rel="noopener"
&gt;Git plugin of oh-my-zsh&lt;/a&gt;, I don&amp;rsquo;t feel there is a great need for such shortcuts.
Let&amp;rsquo;s instead talk about &lt;strong&gt;actual custom commands&lt;/strong&gt;:&lt;/p&gt;
&lt;h2 id="with-parameters"&gt;With Parameters
&lt;/h2&gt;&lt;p&gt;If you use an &lt;em&gt;exclamation mark&lt;/em&gt; before your command, you can run any Shell command you want, even with parameters.
The following example will let you do e.g. &lt;code&gt;git cat 2eea778 package.json&lt;/code&gt; to get the file contents of a file at a certain revision:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-ini" data-lang="ini"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;[alias]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; Output file contents from any revision&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; See https://stackoverflow.com/a/54819889/6435726&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;cat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;!git show &amp;#34;$1:$2&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="pass-it-on"&gt;Pass It On
&lt;/h2&gt;&lt;p&gt;Piping output into other commands is available out of the box.
Executing multiple commands is just a &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; away.&lt;/p&gt;
&lt;p&gt;You may want to break your command into &lt;em&gt;multiple lines&lt;/em&gt;:
Do so by wrapping your command into &lt;strong&gt;quotes&lt;/strong&gt; and prepending every new line with a &lt;strong&gt;backslash&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-ini" data-lang="ini"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; What is the default branch of this repo?&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; The first command asks the remote if the default branch was changed.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;default-branch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;! \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; git remote set-head origin -a &amp;gt; /dev/null \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; &amp;amp;&amp;amp; git rev-parse --abbrev-ref origin/HEAD \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; | sed &amp;#39;s#origin/##&amp;#39;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can also use &lt;em&gt;subshells&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-ini" data-lang="ini"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; Switch to the default branch.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;switch-default&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;!git switch $(git default-branch)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="escaping-can-be-tricky"&gt;Escaping Can Be Tricky
&lt;/h2&gt;&lt;p&gt;If you want to have a &lt;em&gt;literal backslash&lt;/em&gt; in the resulting Shell command, you have to escape it.
Pay attention to the &lt;code&gt;grep&lt;/code&gt; patterns in the following aliases:
Every double backslash of this pattern becomes a single backslash when Git passes the command to the Shell.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-ini" data-lang="ini"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; Which branches have been merged into the default branch on the remote?&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; For safety, manually add names of long-lived branches to the grep pattern.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;remotely-merged-branches&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;! \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; git branch --all --merged $(git default-branch) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; | { grep -vE &amp;#39;^\\*|(\\b($(git default-branch)|develop|main|master|quality)\\b)&amp;#39; || true; } \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; | sed &amp;#39;s#remotes/origin/##&amp;#39;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; Which local branches are not present on the remote (but were once)?&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; NOTE: `git remote prune origin` only deletes local snapshots&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; of remote branches that were deleted on the remote.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; See https://stackoverflow.com/a/48820687/6435726&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; It will not delete local branches where the remote branch is &amp;#34;gone&amp;#34;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; This command finds these local branches.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;local-branches-without-remote&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;! \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; git remote prune origin &amp;amp;&amp;amp; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; git branch --list --format &amp;#39;%(if:equals=[gone])%(upstream:track)%(then)%(refname)%(end)&amp;#39; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; | awk NF \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; | sed &amp;#39;s#refs/heads/##&amp;#39;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I think these are the dangers of every templating language:
You have to account for special characters - but if these special characters happen to be special in someone else&amp;rsquo;s language, things can become unexpectedly complicated.
(Think about Makefiles and &lt;code&gt;$(variables)&lt;/code&gt; vs. &lt;code&gt;$$variables&lt;/code&gt; in rules.)&lt;/p&gt;
&lt;h2 id="parameters-pt-2-default-values"&gt;Parameters Pt. 2: Default Values
&lt;/h2&gt;&lt;p&gt;As with any other Shell function, you can not only have positional parameters but you can also give them default values.
The following alias has a &lt;em&gt;delete flag&lt;/em&gt; that defaults to the safe behavior, but you can overwrite it with &lt;code&gt;git delete-local-branches-without-remote -D&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-ini" data-lang="ini"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; Delete local branches that are not present on the remote&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; (safely, including warnings).&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; You can ignore the warnings by passing &amp;#34;-D&amp;#34; as a parameter.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; NOTE: `git remote prune origin` only deletes local snapshots&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; of remote branches that were deleted on the remote.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; It will not delete local branches where the remote branch is &amp;#34;gone&amp;#34;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;delete-local-branches-without-remote&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;! \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; git local-branches-without-remote \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; | xargs -I {} git branch ${1:-&amp;#39;-d&amp;#39;} {}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This last alias is what finally deletes the remote branches I wanted to target.
It also demonstrates nicely how you can use &lt;em&gt;xargs&lt;/em&gt; to run every Shell command as if it was capable of handling &lt;code&gt;stdin&lt;/code&gt; natively:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-ini" data-lang="ini"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; Delete branches on the remote which were merged.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;push-delete-remotely-merged-branches&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;! \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; git switch-default &amp;amp;&amp;amp; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; git remotely-merged-branches \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; | xargs -I {} git push origin --delete {}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="debugging"&gt;Debugging
&lt;/h2&gt;&lt;p&gt;If you encounter an error message, you can increase the verbosity with this environment variable:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;GIT_TRACE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Deactivate it afterward by closing your terminal session or explicitly with &lt;code&gt;unset GIT_TRACE&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="bringing-it-all-together-multiple-repositories"&gt;Bringing It All Together: Multiple Repositories
&lt;/h2&gt;&lt;p&gt;As a developer, chances are high you have &lt;em&gt;more than just one&lt;/em&gt; Git repository on your machine.
For many everyday use cases (like keeping all your local clones up-to-date), I have been using &lt;a class="link" href="https://github.com/earwig/git-repo-updater" target="_blank" rel="noopener"
&gt;git-repo-updater&lt;/a&gt; with a lot of success and ease.&lt;/p&gt;
&lt;p&gt;But now I discovered I can use it to execute arbitrary commands (and also Git aliases ðŸ˜‰) in multiple Git repos.
With the following Shell function I am wrapping &lt;code&gt;gitup&lt;/code&gt; for convenience:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# Execute a Git command on all Git repositories&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# $1: Path with Git repositories in subdirectories&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# Rest of parameters: Git command (e.g. &amp;#34;status&amp;#34;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;function&lt;/span&gt; git-xargs&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;local&lt;/span&gt; &lt;span class="nv"&gt;filepath&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# shellcheck disable=SC2116&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; gitup --depth -1 &lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="nv"&gt;$filepath&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt; --exec &lt;span class="s2"&gt;&amp;#34;git &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="p"&gt;@:&lt;/span&gt;&lt;span class="nv"&gt;2&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And now I can finally clean up all branches with just one command (and quite pretty output):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;git-xargs ~/Documents push-delete-remotely-merged-branches
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;git-xargs ~/Documents delete-local-branches-without-remote
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description></item></channel></rss>