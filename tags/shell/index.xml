<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Shell on Josia's Blog</title><link>https://jscheytt.github.io/tags/shell/</link><description>Recent content in Shell on Josia's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Josia Scheytt</copyright><lastBuildDate>Wed, 01 Jun 2022 15:04:45 +0200</lastBuildDate><atom:link href="https://jscheytt.github.io/tags/shell/index.xml" rel="self" type="application/rss+xml"/><item><title>My default Makefile Boilerplate code</title><link>https://jscheytt.github.io/p/my-default-makefile-boilerplate-code/</link><pubDate>Wed, 01 Jun 2022 15:04:45 +0200</pubDate><guid>https://jscheytt.github.io/p/my-default-makefile-boilerplate-code/</guid><description>&lt;p&gt;Most of my Makefiles nowadays start with the following stuff at the top of &lt;code&gt;Makefile&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-make" data-lang="make"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# Remove default suffixes as we don&amp;#39;t use them.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nf"&gt;.SUFFIXES&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# Set the Shell to Bash always to avoid surprises.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nv"&gt;SHELL&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; /bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# Auto-generate help texts from end-of-line comments.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# See https://marmelab.com/blog/2016/02/29/auto-documented-makefile.html
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nf"&gt;.PHONY&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nv"&gt;USAGE_TEXT&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; Usage: make &lt;span class="o"&gt;[&lt;/span&gt;make-options&lt;span class="o"&gt;]&lt;/span&gt; &amp;lt;target&amp;gt; &lt;span class="o"&gt;[&lt;/span&gt;options&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nv"&gt;HELPTEXT_HEADING&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; Common Targets:
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;help&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="c"&gt;## Show this help info.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt; @printf &lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;USAGE_TEXT&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;\n&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; @for makefile in &lt;span class="k"&gt;$(&lt;/span&gt;MAKEFILE_LIST&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="se"&gt;&lt;/span&gt; echo&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="se"&gt;&lt;/span&gt; grep &lt;span class="s1"&gt;&amp;#39;^HELPTEXT_HEADING := &amp;#39;&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="nv"&gt;$$&lt;/span&gt;&lt;span class="s2"&gt;makefile&amp;#34;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sed -E &lt;span class="s1"&gt;&amp;#39;s#.* := (.*)#\1#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="se"&gt;&lt;/span&gt; grep -E &lt;span class="s1"&gt;&amp;#39;^[a-zA-Z_\.-]+:.*?## .*$$&amp;#39;&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="nv"&gt;$$&lt;/span&gt;&lt;span class="s2"&gt;makefile&amp;#34;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sort &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="se"&gt;&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;BEGIN {FS = &amp;#34;:.*?## &amp;#34;}; {printf &amp;#34; %-27s %s\n&amp;#34;, $$1, $$2}&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="se"&gt;&lt;/span&gt; &lt;span class="k"&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# Split out Make modules into `helpers/`.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="err"&gt;-include&lt;/span&gt; &lt;span class="err"&gt;helpers/*.mk&lt;/span&gt; &lt;span class="err"&gt;helpers/**/*.mk&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then I extend this either with targets directly in the &lt;code&gt;Makefile&lt;/code&gt; or, mostly later on, with separate &lt;code&gt;.mk&lt;/code&gt; files in the &lt;code&gt;helpers/&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;If I want to mark a target &amp;ldquo;public&amp;rdquo; or document its usage, I will just append &lt;code&gt; ## Usage.&lt;/code&gt; to the end of the target&amp;rsquo;s line.
One example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-make" data-lang="make"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;bootstrap&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;cluster&lt;/span&gt;.&lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="c"&gt;## Bootstrap base resources. Required parameters: cluster_name.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description></item><item><title>The Git Commands You Wish You Always Had</title><link>https://jscheytt.github.io/p/the-git-commands-you-wish-you-always-had/</link><pubDate>Mon, 28 Feb 2022 13:15:29 +0100</pubDate><guid>https://jscheytt.github.io/p/the-git-commands-you-wish-you-always-had/</guid><description>&lt;p&gt;Recently I wanted to do a bulk cleanup on some GitHub repositories I am responsible for, deleting old branches that have already been merged into the default branches.
I first considered performing it through the GitHub API, but then I decided to try doing it via Git itself.&lt;/p&gt;
&lt;p&gt;After I had begun dabbling with a few wrapper scripts, I suddenly remembered something which massively simplified my strategy:
&lt;strong&gt;Git Aliases&lt;/strong&gt;.
These are Git commands you can define yourself, either via CLI or in the Gitconfig file.&lt;/p&gt;
&lt;p&gt;With this article, I want to introduce what I learned about Git aliases – and in the process, you get all the aliases I defined for my cleanup 😉&lt;/p&gt;
&lt;h2 id="defining-shortcuts"&gt;Defining Shortcuts
&lt;/h2&gt;&lt;p&gt;Many articles about Git aliases explain only the &lt;strong&gt;shortcut side&lt;/strong&gt;.
They show e.g. how you can abbreviate &lt;code&gt;git checkout&lt;/code&gt; to &lt;code&gt;git co&lt;/code&gt; by running &lt;code&gt;git config --global alias.co checkout&lt;/code&gt;.
Alternatively to the CLI command, you can add this section to your &lt;code&gt;~/.gitconfig&lt;/code&gt; file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-ini" data-lang="ini"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;[alias]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;co&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;checkout&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nowadays, with the &lt;a class="link" href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git" target="_blank" rel="noopener"
&gt;Git plugin of oh-my-zsh&lt;/a&gt;, I don&amp;rsquo;t feel there is a great need for such shortcuts.
Let&amp;rsquo;s instead talk about &lt;strong&gt;actual custom commands&lt;/strong&gt;:&lt;/p&gt;
&lt;h2 id="with-parameters"&gt;With Parameters
&lt;/h2&gt;&lt;p&gt;If you use an &lt;em&gt;exclamation mark&lt;/em&gt; before your command, you can run any Shell command you want, even with parameters.
The following example will let you do e.g. &lt;code&gt;git cat 2eea778 package.json&lt;/code&gt; to get the file contents of a file at a certain revision:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-ini" data-lang="ini"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;[alias]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; Output file contents from any revision&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; See https://stackoverflow.com/a/54819889/6435726&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;cat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;!git show &amp;#34;$1:$2&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="pass-it-on"&gt;Pass It On
&lt;/h2&gt;&lt;p&gt;Piping output into other commands is available out of the box.
Executing multiple commands is just a &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; away.&lt;/p&gt;
&lt;p&gt;You may want to break your command into &lt;em&gt;multiple lines&lt;/em&gt;:
Do so by wrapping your command into &lt;strong&gt;quotes&lt;/strong&gt; and prepending every new line with a &lt;strong&gt;backslash&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-ini" data-lang="ini"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; What is the default branch of this repo?&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; The first command asks the remote if the default branch was changed.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;default-branch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;! \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; git remote set-head origin -a &amp;gt; /dev/null \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; &amp;amp;&amp;amp; git rev-parse --abbrev-ref origin/HEAD \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; | sed &amp;#39;s#origin/##&amp;#39;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can also use &lt;em&gt;subshells&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-ini" data-lang="ini"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; Switch to the default branch.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;switch-default&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;!git switch $(git default-branch)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="escaping-can-be-tricky"&gt;Escaping Can Be Tricky
&lt;/h2&gt;&lt;p&gt;If you want to have a &lt;em&gt;literal backslash&lt;/em&gt; in the resulting Shell command, you have to escape it.
Pay attention to the &lt;code&gt;grep&lt;/code&gt; patterns in the following aliases:
Every double backslash of this pattern becomes a single backslash when Git passes the command to the Shell.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-ini" data-lang="ini"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; Which branches have been merged into the default branch on the remote?&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; For safety, manually add names of long-lived branches to the grep pattern.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;remotely-merged-branches&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;! \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; git branch --all --merged $(git default-branch) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; | { grep -vE &amp;#39;^\\*|(\\b($(git default-branch)|develop|main|master|quality)\\b)&amp;#39; || true; } \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; | sed &amp;#39;s#remotes/origin/##&amp;#39;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; Which local branches are not present on the remote (but were once)?&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; NOTE: `git remote prune origin` only deletes local snapshots&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; of remote branches that were deleted on the remote.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; See https://stackoverflow.com/a/48820687/6435726&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; It will not delete local branches where the remote branch is &amp;#34;gone&amp;#34;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; This command finds these local branches.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;local-branches-without-remote&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;! \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; git remote prune origin &amp;amp;&amp;amp; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; git branch --list --format &amp;#39;%(if:equals=[gone])%(upstream:track)%(then)%(refname)%(end)&amp;#39; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; | awk NF \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; | sed &amp;#39;s#refs/heads/##&amp;#39;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I think these are the dangers of every templating language:
You have to account for special characters - but if these special characters happen to be special in someone else&amp;rsquo;s language, things can become unexpectedly complicated.
(Think about Makefiles and &lt;code&gt;$(variables)&lt;/code&gt; vs. &lt;code&gt;$$variables&lt;/code&gt; in rules.)&lt;/p&gt;
&lt;h2 id="parameters-pt-2-default-values"&gt;Parameters Pt. 2: Default Values
&lt;/h2&gt;&lt;p&gt;As with any other Shell function, you can not only have positional parameters but you can also give them default values.
The following alias has a &lt;em&gt;delete flag&lt;/em&gt; that defaults to the safe behavior, but you can overwrite it with &lt;code&gt;git delete-local-branches-without-remote -D&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-ini" data-lang="ini"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; Delete local branches that are not present on the remote&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; (safely, including warnings).&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; You can ignore the warnings by passing &amp;#34;-D&amp;#34; as a parameter.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; NOTE: `git remote prune origin` only deletes local snapshots&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; of remote branches that were deleted on the remote.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; It will not delete local branches where the remote branch is &amp;#34;gone&amp;#34;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;delete-local-branches-without-remote&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;! \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; git local-branches-without-remote \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; | xargs -I {} git branch ${1:-&amp;#39;-d&amp;#39;} {}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This last alias is what finally deletes the remote branches I wanted to target.
It also demonstrates nicely how you can use &lt;em&gt;xargs&lt;/em&gt; to run every Shell command as if it was capable of handling &lt;code&gt;stdin&lt;/code&gt; natively:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-ini" data-lang="ini"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;; Delete branches on the remote which were merged.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="na"&gt;push-delete-remotely-merged-branches&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;! \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; git switch-default &amp;amp;&amp;amp; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; git remotely-merged-branches \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s"&gt; | xargs -I {} git push origin --delete {}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="debugging"&gt;Debugging
&lt;/h2&gt;&lt;p&gt;If you encounter an error message, you can increase the verbosity with this environment variable:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;GIT_TRACE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Deactivate it afterward by closing your terminal session or explicitly with &lt;code&gt;unset GIT_TRACE&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="bringing-it-all-together-multiple-repositories"&gt;Bringing It All Together: Multiple Repositories
&lt;/h2&gt;&lt;p&gt;As a developer, chances are high you have &lt;em&gt;more than just one&lt;/em&gt; Git repository on your machine.
For many everyday use cases (like keeping all your local clones up-to-date), I have been using &lt;a class="link" href="https://github.com/earwig/git-repo-updater" target="_blank" rel="noopener"
&gt;git-repo-updater&lt;/a&gt; with a lot of success and ease.&lt;/p&gt;
&lt;p&gt;But now I discovered I can use it to execute arbitrary commands (and also Git aliases 😉) in multiple Git repos.
With the following Shell function I am wrapping &lt;code&gt;gitup&lt;/code&gt; for convenience:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# Execute a Git command on all Git repositories&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# $1: Path with Git repositories in subdirectories&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# Rest of parameters: Git command (e.g. &amp;#34;status&amp;#34;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;function&lt;/span&gt; git-xargs&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;local&lt;/span&gt; &lt;span class="nv"&gt;filepath&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# shellcheck disable=SC2116&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; gitup --depth -1 &lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="nv"&gt;$filepath&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt; --exec &lt;span class="s2"&gt;&amp;#34;git &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="p"&gt;@:&lt;/span&gt;&lt;span class="nv"&gt;2&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And now I can finally clean up all branches with just one command (and quite pretty output):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;git-xargs ~/Documents push-delete-remotely-merged-branches
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;git-xargs ~/Documents delete-local-branches-without-remote
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description></item><item><title>The Story of My First Makefile — Half-Versioned Secrets Management</title><link>https://jscheytt.github.io/p/the-story-of-my-first-makefile-half-versioned-secrets-management/</link><pubDate>Mon, 06 Sep 2021 13:38:15 +0200</pubDate><guid>https://jscheytt.github.io/p/the-story-of-my-first-makefile-half-versioned-secrets-management/</guid><description>&lt;p&gt;As a DevOps Engineer one key skill is &lt;strong&gt;automating repetitive tasks&lt;/strong&gt;.
What most people grab for intuitively is writing Shell scripts (be it Bash, zsh, fish or whichever flavor you prefer).
And there are a lot many good reasons to do so:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It is closest to typing commands directly in the terminal.&lt;/li&gt;
&lt;li&gt;You don&amp;rsquo;t have to learn a dedicated programming language.&lt;/li&gt;
&lt;li&gt;It is very portable to other platforms like e.g. a CI server.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But once you start managing an increasing number of tasks with your scripts, you start to face another problem:
How do you &lt;em&gt;manage your scripts&lt;/em&gt;?&lt;/p&gt;
&lt;p&gt;Personally, I have always loved being able to enter some new place where &lt;strong&gt;conventions&lt;/strong&gt; were already in place.
It takes away so much work and mental effort at the beginning, and you can just get to work quickly.
(That might explain why I fell in love with ❤️ &lt;a class="link" href="https://rubyonrails.org/doctrine/#convention-over-configuration" target="_blank" rel="noopener"
&gt;Ruby on Rails&lt;/a&gt; before I dug into 💎 Ruby.)&lt;/p&gt;
&lt;p&gt;Shell scripts by their very nature do not pose any restrictions regarding e.g. naming patterns or directory structures.
Honestly, I think there never will be, and that is ok.
But what I have come to appreciate a lot recently is &lt;strong&gt;&lt;a class="link" href="https://www.gnu.org/software/make/" target="_blank" rel="noopener"
&gt;Make&lt;/a&gt;&lt;/strong&gt; as a &lt;strong&gt;companion&lt;/strong&gt; for my Shell scripts.&lt;/p&gt;
&lt;h2 id="-make-vs--shell-in-a--nutshell"&gt;🏗 Make vs. 🐚 Shell in a 🥜 Nutshell
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Purpose: Make is good at &lt;strong&gt;creating files&lt;/strong&gt;, Shell is good at &lt;strong&gt;executing scripts&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Portability: If your system has Bash, chances are pretty high that Make is also available.&lt;/li&gt;
&lt;li&gt;Developer API: Make has a &lt;strong&gt;clear entrypoint&lt;/strong&gt; (namely &lt;code&gt;make&lt;/code&gt;), Shell can be everything you want it to be.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Make is a tool that has its origin in the world of compiled languages, especially C.
Compiling source code into binary artifacts (and doing so 🏎 &lt;em&gt;economically&lt;/em&gt;) is what Make was originally designed for.
I mean, the name of a tool should make its use clear, but let me just state this again for my future self:
Make is meant to 🏗 make (create) files.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;It&amp;rsquo;s all about target files.&lt;/strong&gt;
That&amp;rsquo;s why it makes sense to approach a Makefile with a mindset of &amp;ldquo;What do I want to create/build?&amp;rdquo; instead of &amp;ldquo;What do I want to perform?&amp;rdquo;
To me this sounds very reminiscent of the distinction between &lt;em&gt;declarative and imperative&lt;/em&gt; programming.&lt;/p&gt;
&lt;h2 id="safely-versioned-secrets-management"&gt;Safely Versioned Secrets Management
&lt;/h2&gt;&lt;p&gt;My concrete entrypoint into Make was the following use case I had lately, and it hopefully helps to illustrate the point of target files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;☸️ You have 2 AWS accounts with 1 &lt;strong&gt;Kubernetes&lt;/strong&gt; cluster each.
(One is for running a dev and a staging environment, the other one is running the production environment.)&lt;/li&gt;
&lt;li&gt;🔑 Secrets are stored in AWS &lt;strong&gt;Secrets Manager&lt;/strong&gt; and synced into the cluster via &lt;a class="link" href="https://github.com/external-secrets/kubernetes-external-secrets" target="_blank" rel="noopener"
&gt;ExternalSecrets&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;⛔️ You are &lt;strong&gt;not allowed&lt;/strong&gt; to store secrets in Git, not even in encrypted form.&lt;/li&gt;
&lt;li&gt;🪣 The secrets are JSON files and the &lt;strong&gt;key names&lt;/strong&gt; are important, so you want to store them in Git.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What I did as a first step was to create sample secrets files that contained the keys but no valid data (kind of the &lt;em&gt;schema&lt;/em&gt; of the secrets):&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;secrets
├── dev # One directory per target environment
│   └── .keep
├── staging
│   └── .keep
├── prod
│   └── .keep
├── config1.sample.json # One sample file per secret
├── service2.sample.json
└── service3.sample.json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I put the keys I needed into the sample files and as a value a description of what to put in (or e.g. from which Password Service to fetch the value from).
The file &lt;code&gt;service2.sample.json&lt;/code&gt; would e.g. look like this.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-json" data-lang="json"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;EXTERNAL_API_KEY&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;API Key of EXTERNAL_SERVICE&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;CLOUD_SERVICE_CLIENT_SECRET&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;client secret for accessing CLOUD_SERVICE&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;CLOUD_SERVICE_PASSWORD&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;password for accessing CLOUD_SERVICE&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;BASIC_AUTH_PASSWORD&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;password for sending via Basic Auth&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The target structure I wanted to achieve was this:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;secrets
├── dev
│   ├── config1.json # This file contains the *keys* of
│ │ # secrets/config1.sample.json
│ │ # and the actual secret *values*!
│   ├── service2.json
│   ├── service3.json
│   └── .keep
├── staging
│   ├── config1.json # Contains key of sample file and
│ │ # values for staging environment.
│   ├── service2.json
│   ├── service3.json
│   └── .keep
├── prod
│   ├── config1.json
│   ├── service2.json
│   ├── service3.json
│   └── .keep
├── config1.sample.json
├── service2.sample.json
└── service3.sample.json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In order to not commit any actual secrets into version control, I added the following entries to my &lt;strong&gt;.gitignore&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# Ignore secret data ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;secrets/**/*.json
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# ... but keep the samples&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;!secrets/*.sample.json
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="copying-the-samples"&gt;Copying the Samples
&lt;/h3&gt;&lt;p&gt;Now how do you copy the files to all environment&amp;rsquo;s directories?
And how do you make sure you copy them &lt;em&gt;exactly once&lt;/em&gt; (so you don&amp;rsquo;t lose the secrets you already entered)?&lt;/p&gt;
&lt;p&gt;You could create a script with the following logic:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# For each environment directory:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;## For each sample file:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;### Extract the service name&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;### Check if target secret file already exists&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;### If not, copy sample to target file&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;But now, 🏗 Make to the rescue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-make" data-lang="make"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;### Variables
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# Fetch all sample files.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nv"&gt;secrets_samples&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;wildcard secrets/*.sample.json&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# Construct the paths for all dev secrets destinations.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nv"&gt;dev_secrets&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;patsubst secrets/%.sample.json,secrets/dev/%.json,&lt;span class="k"&gt;$(&lt;/span&gt;secrets_samples&lt;span class="k"&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# Construct the paths for all staging secrets destinations.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nv"&gt;staging_secrets&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;patsubst secrets/dev/%,secrets/staging/%,&lt;span class="k"&gt;$(&lt;/span&gt;dev_secrets&lt;span class="k"&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# Construct the paths for all staging secrets destinations.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nv"&gt;prod_secrets&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;patsubst secrets/dev/%,secrets/prod/%,&lt;span class="k"&gt;$(&lt;/span&gt;dev_secrets&lt;span class="k"&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# Gather the paths of all secrets&amp;#39; destinations.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nv"&gt;all_secrets&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;dev_secrets&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;staging_secrets&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;prod_secrets&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;### Rules
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 🎯 Purpose: &amp;#34;Copy all samples to their destinations.&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 🤓 What Make sees: &amp;#34;When you build the file secrets.copy-templates,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# make sure that all files in $(all_secrets) have been built first.&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 👩‍🏫 Explanation: A rule can be empty, and a rule can have prerequisites
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# on the first line. I like to think of such a rule as a kind of shortcut.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nf"&gt;secrets.copy-templates&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;all_secrets&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 🎯 Purpose: &amp;#34;Ensure that Make still runs the job &amp;#39;secrets.copy-templates&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# even if a file called &amp;#39;secrets.copy-templates&amp;#39; is created.&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 🤓 What Make sees: &amp;#34;I am supposed to always build secrets.copy-templates
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# even if that file already exists.&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nf"&gt;.PHONY&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;secrets&lt;/span&gt;.&lt;span class="n"&gt;copy&lt;/span&gt;-&lt;span class="n"&gt;templates&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 🎯 Purpose: &amp;#34;Copy the file on the right to the file on the left.&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 🤓 What Make sees: &amp;#34;When a file matching the pattern secrets/dev/(.*).json
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# is built, execute this rule.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# Also first make sure that the corresponding file secrets/$1.sample.json
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# has been built before.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# And the rule is: Copy the source file on the right ($&amp;lt;) to the destination
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# file on the left ($@).&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 👩‍🏫 Explanation: These 3 rules are applied when you call secrets.copy-templates
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# because it requires $(all_secrets) to be built.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nf"&gt;secrets/dev/%.json&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;secrets&lt;/span&gt;/%.&lt;span class="n"&gt;sample&lt;/span&gt;.&lt;span class="n"&gt;json&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; cp $&amp;lt; &lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;secrets/staging/%.json&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;secrets&lt;/span&gt;/%.&lt;span class="n"&gt;sample&lt;/span&gt;.&lt;span class="n"&gt;json&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; cp $&amp;lt; &lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;secrets/prod/%.json&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;secrets&lt;/span&gt;/%.&lt;span class="n"&gt;sample&lt;/span&gt;.&lt;span class="n"&gt;json&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; cp $&amp;lt; &lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you now execute &lt;code&gt;make secrets.copy-templates&lt;/code&gt;, the sample files will be copied to all environment directories.
And if you run that same command again, 🙊 &lt;strong&gt;Make will not copy anything&lt;/strong&gt; because it intelligenty detected that the source files have not changed since the last execution.&lt;/p&gt;
&lt;p&gt;The code above is certainly not optimal - I bet you could abstract away the environment names with bit of metaprogramming, but let&amp;rsquo;s not optimize prematurely.
I think the result is already impressive, especially if you consider the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;☝️ You don&amp;rsquo;t even have to call the job explicitly to run it.
As long as &lt;code&gt;secrets.copy-templates&lt;/code&gt; is the first build defined in the Makefile, you can even execute just &lt;code&gt;make&lt;/code&gt; &lt;em&gt;without any parameters&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;👨‍💻 Onboarding a new colleague to your repository now sounds a lot more like:
&amp;ldquo;Yes, do read the README, but above all execute &lt;code&gt;make&lt;/code&gt;.&amp;rdquo;
&lt;ul&gt;
&lt;li&gt;⛑ This is especially true if your Makefile contains &lt;strong&gt;&lt;a class="link" href="https://marmelab.com/blog/2016/02/29/auto-documented-makefile.html" target="_blank" rel="noopener"
&gt;good help texts&lt;/a&gt;&lt;/strong&gt; for every rule.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="how-not-to-shoot-yourself-in-the-foot"&gt;How Not To Shoot Yourself in the Foot
&lt;/h4&gt;&lt;p&gt;Make was made primarily for building binaries from source code.
The fact that we are able to use it in the way described above comes with a warning:
If you do the following, you will lose the secret data you already entered into the secret files:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Execute &lt;code&gt;make secrets.copy-templates&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Edit a &lt;strong&gt;sample file&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Execute &lt;code&gt;make secrets.copy-templates&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;💥 Make will &lt;strong&gt;copy and overwrite&lt;/strong&gt; the edited sample file to all environment secret files.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Why?
Make compares timestamps, and when the source has a newer last-modified timestamp than the destination it will execute the rule&lt;/p&gt;
&lt;p&gt;Can we circumvent this?
We sure can.
You can either make sure that you edit each environment file after editing the sample file.
Or you change the last-modified timestamp &lt;strong&gt;via a build&lt;/strong&gt; in the Makefile 😉:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-make" data-lang="make"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;secrets.ensure-copy-once&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; f in &lt;span class="k"&gt;$(&lt;/span&gt;all_secrets&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -f &lt;span class="nv"&gt;$$&lt;/span&gt;f &lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; touch &lt;span class="nv"&gt;$$&lt;/span&gt;f&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now whenever you edit a sample file &lt;em&gt;after the initial secrets.copy-templates&lt;/em&gt; you run this build via &lt;code&gt;make secrets.ensure-copy-once&lt;/code&gt; and 🛡 your secrets will not be deleted.&lt;/p&gt;
&lt;h3 id="extension-environment-specific-sample-files"&gt;Extension: Environment-specific Sample Files
&lt;/h3&gt;&lt;p&gt;One implicit assumption in my structure was that the secrets in service2 will always have the same schema &lt;strong&gt;in every environment&lt;/strong&gt;.
One day it so happened that service2 needed to have additional keys on prod, but they &lt;strong&gt;should not be present&lt;/strong&gt; on dev or staging.&lt;/p&gt;
&lt;p&gt;I adjusted my desired structure like this:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;secrets
├── dev
│   ├── config1.json
│   ├── service2.json # Contains keys from service2.sample.json
│   ├── service3.json
│   └── .keep
├── staging
│   ├── config1.json
│   ├── service2.json # Contains keys from service2.sample.json
│   ├── service3.json
│   └── .keep
├── prod
│   ├── config1.json
│   ├── service2.json # Contains keys from service2.sample.prod.json
│   ├── service3.json
│   └── .keep
├── config1.sample.json
├── service2.sample.json # Default sample file
├── service2.sample.prod.json # Prod-specific sample file
└── service3.sample.json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And I wrote my first &lt;strong&gt;Makefile function&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-make" data-lang="make"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# A Make function can take in an arbitrary number of numbered parameters.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="err"&gt;define&lt;/span&gt; &lt;span class="err"&gt;copy_template&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="err"&gt;cp&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;1&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;2&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="c"&gt;# Check if there is a more environment-specific sample file
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;eval&lt;/span&gt; ENVIRONMENT :&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;shell &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;2&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sed -E &lt;span class="s1"&gt;&amp;#39;s#secrets/(.*)/.*#\1#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;eval&lt;/span&gt; ENVIRONMENT_SAMPLE_FILE :&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;patsubst %.sample.json,%.sample.&lt;span class="k"&gt;$(&lt;/span&gt;ENVIRONMENT&lt;span class="k"&gt;)&lt;/span&gt;.json,&lt;span class="k"&gt;$(&lt;/span&gt;1&lt;span class="k"&gt;)))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; @# If environment-specific file exists, copy it to destination
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -f &lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;ENVIRONMENT_SAMPLE_FILE&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt; cp &lt;span class="k"&gt;$(&lt;/span&gt;ENVIRONMENT_SAMPLE_FILE&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;2&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;endef&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# Calling a Make function works by executing &amp;#39;call&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# with the function name and all its parameters as a list.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# My previous rules now became this:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nf"&gt;secrets/dev/%.json&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;secrets&lt;/span&gt;/%.&lt;span class="n"&gt;sample&lt;/span&gt;.&lt;span class="n"&gt;json&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;$(&lt;/span&gt;call copy_template,$&amp;lt;,&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;secrets/staging/%.json&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;secrets&lt;/span&gt;/%.&lt;span class="n"&gt;sample&lt;/span&gt;.&lt;span class="n"&gt;json&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;$(&lt;/span&gt;call copy_template,$&amp;lt;,&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;secrets/prod/%.json&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;secrets&lt;/span&gt;/%.&lt;span class="n"&gt;sample&lt;/span&gt;.&lt;span class="n"&gt;json&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;$(&lt;/span&gt;call copy_template,$&amp;lt;,&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="-perfect-symphony-calling-scripts-from-make"&gt;🍣 Perfect Symphony: Calling Scripts From Make
&lt;/h3&gt;&lt;p&gt;It&amp;rsquo;s all good and nice to have your secrets created, but how do you deploy them to AWS Secrets Manager?
Of course you write a thin wrapper around the wonderfully verbose AWS CLI:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#!/usr/bin/env bash
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt; -euo pipefail
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# set -x # DEBUG&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nv"&gt;secret_name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# Use second argument or read stdin&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nv"&gt;secret_value&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;2&lt;/span&gt;&lt;span class="k"&gt;:-$(&lt;/span&gt;cat -&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="nv"&gt;$secret_value&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt; &lt;span class="c1"&gt;# DEBUG&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# Create secret in idempotent way, avoid script from failing&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;set&lt;/span&gt; +e
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;aws secretsmanager create-secret --name &lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="nv"&gt;$secret_name&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&amp;gt; /dev/null
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;set&lt;/span&gt; -e
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# Put secret value and output response to stdout&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;aws secretsmanager put-secret-value --secret-id &lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="nv"&gt;$secret_name&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt; &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="se"&gt;&lt;/span&gt; --secret-string &lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="nv"&gt;$secret_value&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; cat
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In your terminal you would call it e.g. like this:&lt;br&gt;
&lt;code&gt;./helpers/deploy-secret.sh envs/dev/config1-secrets &amp;lt; secrets/dev/config1.json&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s make a generic rule in Make to execute this script:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-make" data-lang="make"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# The dependency on $(all_secrets) is to make sure that the secrets files exist
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# before deploying them.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nf"&gt;secret.deploy&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;all_secrets&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ./helpers/deploy-secret.sh &lt;span class="k"&gt;$(&lt;/span&gt;name&lt;span class="k"&gt;)&lt;/span&gt; &amp;lt; secrets/&lt;span class="k"&gt;$(&lt;/span&gt;environment&lt;span class="k"&gt;)&lt;/span&gt;/&lt;span class="k"&gt;$(&lt;/span&gt;filename&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The call to the script that you executed above would become this:&lt;br&gt;
&lt;code&gt;make secret.deploy name=envs/dev/config1-secrets environment=dev filename=config1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;As we have multiple services, let&amp;rsquo;s add one rule per service:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-make" data-lang="make"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# The secret values in this one are the same across all environments
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nf"&gt;secret.deploy.config1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;$(&lt;/span&gt;MAKE&lt;span class="k"&gt;)&lt;/span&gt; secret.deploy &lt;span class="nv"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;envs/config1-secrets &lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;config1.json
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# service2 has different secret values on the different environments
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nf"&gt;secret.deploy.service2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;$(&lt;/span&gt;MAKE&lt;span class="k"&gt;)&lt;/span&gt; secret.deploy &lt;span class="nv"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;envs/&lt;span class="k"&gt;$(&lt;/span&gt;environment&lt;span class="k"&gt;)&lt;/span&gt;/service2-secrets &lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;service2.json
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# service 3 also has environment-specific secret values
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nf"&gt;secret.deploy.service3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;$(&lt;/span&gt;MAKE&lt;span class="k"&gt;)&lt;/span&gt; secret.deploy &lt;span class="nv"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;envs/&lt;span class="k"&gt;$(&lt;/span&gt;environment&lt;span class="k"&gt;)&lt;/span&gt;/service3-secrets &lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;service3.json
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we can tie these together into one rule for a whole environment:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-make" data-lang="make"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# Deploy all secrets for one environment
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nf"&gt;secrets.deploy.all&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;$(&lt;/span&gt;MAKE&lt;span class="k"&gt;)&lt;/span&gt; secret.deploy.config1
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;$(&lt;/span&gt;MAKE&lt;span class="k"&gt;)&lt;/span&gt; secret.deploy.service2
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;$(&lt;/span&gt;MAKE&lt;span class="k"&gt;)&lt;/span&gt; secret.deploy.service3
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# Deploy all secrets for the dev cluster
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nf"&gt;secrets.deploy.dev&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;$(&lt;/span&gt;MAKE&lt;span class="k"&gt;)&lt;/span&gt; secrets.deploy.all &lt;span class="nv"&gt;environment&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;dev
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;$(&lt;/span&gt;MAKE&lt;span class="k"&gt;)&lt;/span&gt; secrets.deploy.all &lt;span class="nv"&gt;environment&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;staging
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# Deploy all secrets for the prod cluster
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nf"&gt;secrets.deploy.prod&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;$(&lt;/span&gt;MAKE&lt;span class="k"&gt;)&lt;/span&gt; secrets.deploy.all &lt;span class="nv"&gt;environment&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;prod
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;✅ Once you are authenticated to the corresponding AWS account, you can deploy your secrets with either &lt;code&gt;make secrets.deploy.dev&lt;/code&gt; or &lt;code&gt;make secrets.deploy.prod&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="summarizing"&gt;Summarizing
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Make gives you a consistent and clean Developer API.&lt;/li&gt;
&lt;li&gt;Make is almost universally installed everywhere.&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t decide between either Make &lt;strong&gt;or&lt;/strong&gt; Shell - use both together.
Refactor more complex logic into separate Shell scripts (like isolated functions) which are called from within Make.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can check out the entire Makefile (including the secrets structure and scripts) in this &lt;a class="link" href="https://github.com/jscheytt/jscheytt.github.io.hugo/tree/main/content/post/story-first-makefile" target="_blank" rel="noopener"
&gt;Git repo&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="credits"&gt;Credits
&lt;/h2&gt;&lt;p&gt;I am indebted to the following parties in making my start into the world of Make a lot smoother than I expected:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Isaac Z. Schlueter for his &lt;a class="link" href="https://gist.github.com/isaacs/62a2d1825d04437c6f08" target="_blank" rel="noopener"
&gt;interactive Gist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The guys at &lt;a class="link" href="https://www.upbound.io/" target="_blank" rel="noopener"
&gt;Upbound&lt;/a&gt; for creating &lt;a class="link" href="https://crossplane.io/" target="_blank" rel="noopener"
&gt;Crossplane&lt;/a&gt; where they use Make in &lt;a class="link" href="https://github.com/crossplane/provider-aws" target="_blank" rel="noopener"
&gt;their providers&lt;/a&gt; and even distribute &lt;a class="link" href="https://github.com/upbound/build" target="_blank" rel="noopener"
&gt;common functionality&lt;/a&gt; as a Git submodule&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>