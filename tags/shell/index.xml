<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Shell on Josia's Blog</title><link>https://jscheytt.github.io/tags/shell/</link><description>Recent content in Shell on Josia's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Josia Scheytt</copyright><lastBuildDate>Wed, 01 Jun 2022 15:04:45 +0200</lastBuildDate><atom:link href="https://jscheytt.github.io/tags/shell/index.xml" rel="self" type="application/rss+xml"/><item><title>My default Makefile Boilerplate code</title><link>https://jscheytt.github.io/p/my-default-makefile-boilerplate-code/</link><pubDate>Wed, 01 Jun 2022 15:04:45 +0200</pubDate><guid>https://jscheytt.github.io/p/my-default-makefile-boilerplate-code/</guid><description>&lt;p>Most of my Makefiles nowadays start with the following stuff at the top of &lt;code>Makefile&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-make" data-lang="make">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Remove default suffixes as we don&amp;#39;t use them.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nf">.SUFFIXES&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Set the Shell to Bash always to avoid surprises.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nv">SHELL&lt;/span> &lt;span class="o">:=&lt;/span> /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Auto-generate help texts from end-of-line comments.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># See https://marmelab.com/blog/2016/02/29/auto-documented-makefile.html
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nf">.PHONY&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">help&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">USAGE_TEXT&lt;/span> &lt;span class="o">:=&lt;/span> Usage: make &lt;span class="o">[&lt;/span>make-options&lt;span class="o">]&lt;/span> &amp;lt;target&amp;gt; &lt;span class="o">[&lt;/span>options&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">HELPTEXT_HEADING&lt;/span> &lt;span class="o">:=&lt;/span> Common Targets:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">help&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="c">## Show this help info.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span> @printf &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>USAGE_TEXT&lt;span class="k">)&lt;/span>&lt;span class="s2">\n&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @for makefile in &lt;span class="k">$(&lt;/span>MAKEFILE_LIST&lt;span class="k">)&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> echo&lt;span class="p">;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> grep &lt;span class="s1">&amp;#39;^HELPTEXT_HEADING := &amp;#39;&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$$&lt;/span>&lt;span class="s2">makefile&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> sed -E &lt;span class="s1">&amp;#39;s#.* := (.*)#\1#&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> grep -E &lt;span class="s1">&amp;#39;^[a-zA-Z_\.-]+:.*?## .*$$&amp;#39;&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$$&lt;/span>&lt;span class="s2">makefile&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> sort &lt;span class="p">|&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> awk &lt;span class="s1">&amp;#39;BEGIN {FS = &amp;#34;:.*?## &amp;#34;}; {printf &amp;#34; %-27s %s\n&amp;#34;, $$1, $$2}&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="k">done&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Split out Make modules into `helpers/`.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="err">-include&lt;/span> &lt;span class="err">helpers/*.mk&lt;/span> &lt;span class="err">helpers/**/*.mk&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then I extend this either with targets directly in the &lt;code>Makefile&lt;/code> or, mostly later on, with separate &lt;code>.mk&lt;/code> files in the &lt;code>helpers/&lt;/code> directory.&lt;/p>
&lt;p>If I want to mark a target &amp;ldquo;public&amp;rdquo; or document its usage, I will just append &lt;code> ## Usage.&lt;/code> to the end of the target&amp;rsquo;s line.
One example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-make" data-lang="make">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">bootstrap&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">cluster&lt;/span>.&lt;span class="n">local&lt;/span> &lt;span class="c">## Bootstrap base resources. Required parameters: cluster_name.
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>The Git Commands You Wish You Always Had</title><link>https://jscheytt.github.io/p/the-git-commands-you-wish-you-always-had/</link><pubDate>Mon, 28 Feb 2022 13:15:29 +0100</pubDate><guid>https://jscheytt.github.io/p/the-git-commands-you-wish-you-always-had/</guid><description>&lt;p>Recently I wanted to do a bulk cleanup on some GitHub repositories I am responsible for, deleting old branches that have already been merged into the default branches.
I first considered performing it through the GitHub API, but then I decided to try doing it via Git itself.&lt;/p>
&lt;p>After I had begun dabbling with a few wrapper scripts, I suddenly remembered something which massively simplified my strategy:
&lt;strong>Git Aliases&lt;/strong>.
These are Git commands you can define yourself, either via CLI or in the Gitconfig file.&lt;/p>
&lt;p>With this article, I want to introduce what I learned about Git aliases – and in the process, you get all the aliases I defined for my cleanup 😉&lt;/p>
&lt;h2 id="defining-shortcuts">Defining Shortcuts
&lt;/h2>&lt;p>Many articles about Git aliases explain only the &lt;strong>shortcut side&lt;/strong>.
They show e.g. how you can abbreviate &lt;code>git checkout&lt;/code> to &lt;code>git co&lt;/code> by running &lt;code>git config --global alias.co checkout&lt;/code>.
Alternatively to the CLI command, you can add this section to your &lt;code>~/.gitconfig&lt;/code> file:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="k">[alias]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">co&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">checkout&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Nowadays, with the &lt;a class="link" href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git" target="_blank" rel="noopener"
>Git plugin of oh-my-zsh&lt;/a>, I don&amp;rsquo;t feel there is a great need for such shortcuts.
Let&amp;rsquo;s instead talk about &lt;strong>actual custom commands&lt;/strong>:&lt;/p>
&lt;h2 id="with-parameters">With Parameters
&lt;/h2>&lt;p>If you use an &lt;em>exclamation mark&lt;/em> before your command, you can run any Shell command you want, even with parameters.
The following example will let you do e.g. &lt;code>git cat 2eea778 package.json&lt;/code> to get the file contents of a file at a certain revision:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="k">[alias]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; Output file contents from any revision&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; See https://stackoverflow.com/a/54819889/6435726&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">cat&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">!git show &amp;#34;$1:$2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="pass-it-on">Pass It On
&lt;/h2>&lt;p>Piping output into other commands is available out of the box.
Executing multiple commands is just a &lt;code>&amp;amp;&amp;amp;&lt;/code> away.&lt;/p>
&lt;p>You may want to break your command into &lt;em>multiple lines&lt;/em>:
Do so by wrapping your command into &lt;strong>quotes&lt;/strong> and prepending every new line with a &lt;strong>backslash&lt;/strong>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; What is the default branch of this repo?&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; The first command asks the remote if the default branch was changed.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">default-branch&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;! \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> git remote set-head origin -a &amp;gt; /dev/null \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;amp;&amp;amp; git rev-parse --abbrev-ref origin/HEAD \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> | sed &amp;#39;s#origin/##&amp;#39;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can also use &lt;em>subshells&lt;/em>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; Switch to the default branch.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">switch-default&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">!git switch $(git default-branch)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="escaping-can-be-tricky">Escaping Can Be Tricky
&lt;/h2>&lt;p>If you want to have a &lt;em>literal backslash&lt;/em> in the resulting Shell command, you have to escape it.
Pay attention to the &lt;code>grep&lt;/code> patterns in the following aliases:
Every double backslash of this pattern becomes a single backslash when Git passes the command to the Shell.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; Which branches have been merged into the default branch on the remote?&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; For safety, manually add names of long-lived branches to the grep pattern.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">remotely-merged-branches&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;! \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> git branch --all --merged $(git default-branch) \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> | { grep -vE &amp;#39;^\\*|(\\b($(git default-branch)|develop|main|master|quality)\\b)&amp;#39; || true; } \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> | sed &amp;#39;s#remotes/origin/##&amp;#39;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; Which local branches are not present on the remote (but were once)?&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; NOTE: `git remote prune origin` only deletes local snapshots&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; of remote branches that were deleted on the remote.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; See https://stackoverflow.com/a/48820687/6435726&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; It will not delete local branches where the remote branch is &amp;#34;gone&amp;#34;.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; This command finds these local branches.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">local-branches-without-remote&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;! \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> git remote prune origin &amp;amp;&amp;amp; \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> git branch --list --format &amp;#39;%(if:equals=[gone])%(upstream:track)%(then)%(refname)%(end)&amp;#39; \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> | awk NF \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> | sed &amp;#39;s#refs/heads/##&amp;#39;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>I think these are the dangers of every templating language:
You have to account for special characters - but if these special characters happen to be special in someone else&amp;rsquo;s language, things can become unexpectedly complicated.
(Think about Makefiles and &lt;code>$(variables)&lt;/code> vs. &lt;code>$$variables&lt;/code> in rules.)&lt;/p>
&lt;h2 id="parameters-pt-2-default-values">Parameters Pt. 2: Default Values
&lt;/h2>&lt;p>As with any other Shell function, you can not only have positional parameters but you can also give them default values.
The following alias has a &lt;em>delete flag&lt;/em> that defaults to the safe behavior, but you can overwrite it with &lt;code>git delete-local-branches-without-remote -D&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; Delete local branches that are not present on the remote&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; (safely, including warnings).&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; You can ignore the warnings by passing &amp;#34;-D&amp;#34; as a parameter.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; NOTE: `git remote prune origin` only deletes local snapshots&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; of remote branches that were deleted on the remote.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; It will not delete local branches where the remote branch is &amp;#34;gone&amp;#34;.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">delete-local-branches-without-remote&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;! \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> git local-branches-without-remote \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> | xargs -I {} git branch ${1:-&amp;#39;-d&amp;#39;} {}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This last alias is what finally deletes the remote branches I wanted to target.
It also demonstrates nicely how you can use &lt;em>xargs&lt;/em> to run every Shell command as if it was capable of handling &lt;code>stdin&lt;/code> natively:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">; Delete branches on the remote which were merged.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">push-delete-remotely-merged-branches&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;! \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> git switch-default &amp;amp;&amp;amp; \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> git remotely-merged-branches \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> | xargs -I {} git push origin --delete {}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="debugging">Debugging
&lt;/h2>&lt;p>If you encounter an error message, you can increase the verbosity with this environment variable:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">export&lt;/span> &lt;span class="nv">GIT_TRACE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Deactivate it afterward by closing your terminal session or explicitly with &lt;code>unset GIT_TRACE&lt;/code>.&lt;/p>
&lt;h2 id="bringing-it-all-together-multiple-repositories">Bringing It All Together: Multiple Repositories
&lt;/h2>&lt;p>As a developer, chances are high you have &lt;em>more than just one&lt;/em> Git repository on your machine.
For many everyday use cases (like keeping all your local clones up-to-date), I have been using &lt;a class="link" href="https://github.com/earwig/git-repo-updater" target="_blank" rel="noopener"
>git-repo-updater&lt;/a> with a lot of success and ease.&lt;/p>
&lt;p>But now I discovered I can use it to execute arbitrary commands (and also Git aliases 😉) in multiple Git repos.
With the following Shell function I am wrapping &lt;code>gitup&lt;/code> for convenience:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Execute a Git command on all Git repositories&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># $1: Path with Git repositories in subdirectories&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Rest of parameters: Git command (e.g. &amp;#34;status&amp;#34;)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">function&lt;/span> git-xargs&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">local&lt;/span> &lt;span class="nv">filepath&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># shellcheck disable=SC2116&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> gitup --depth -1 &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$filepath&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> --exec &lt;span class="s2">&amp;#34;git &lt;/span>&lt;span class="k">$(&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="p">@:&lt;/span>&lt;span class="nv">2&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And now I can finally clean up all branches with just one command (and quite pretty output):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">git-xargs ~/Documents push-delete-remotely-merged-branches
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git-xargs ~/Documents delete-local-branches-without-remote
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>The Story of My First Makefile — Half-Versioned Secrets Management</title><link>https://jscheytt.github.io/p/the-story-of-my-first-makefile-half-versioned-secrets-management/</link><pubDate>Mon, 06 Sep 2021 13:38:15 +0200</pubDate><guid>https://jscheytt.github.io/p/the-story-of-my-first-makefile-half-versioned-secrets-management/</guid><description>&lt;p>As a DevOps Engineer one key skill is &lt;strong>automating repetitive tasks&lt;/strong>.
What most people grab for intuitively is writing Shell scripts (be it Bash, zsh, fish or whichever flavor you prefer).
And there are a lot many good reasons to do so:&lt;/p>
&lt;ol>
&lt;li>It is closest to typing commands directly in the terminal.&lt;/li>
&lt;li>You don&amp;rsquo;t have to learn a dedicated programming language.&lt;/li>
&lt;li>It is very portable to other platforms like e.g. a CI server.&lt;/li>
&lt;/ol>
&lt;p>But once you start managing an increasing number of tasks with your scripts, you start to face another problem:
How do you &lt;em>manage your scripts&lt;/em>?&lt;/p>
&lt;p>Personally, I have always loved being able to enter some new place where &lt;strong>conventions&lt;/strong> were already in place.
It takes away so much work and mental effort at the beginning, and you can just get to work quickly.
(That might explain why I fell in love with ❤️ &lt;a class="link" href="https://rubyonrails.org/doctrine/#convention-over-configuration" target="_blank" rel="noopener"
>Ruby on Rails&lt;/a> before I dug into 💎 Ruby.)&lt;/p>
&lt;p>Shell scripts by their very nature do not pose any restrictions regarding e.g. naming patterns or directory structures.
Honestly, I think there never will be, and that is ok.
But what I have come to appreciate a lot recently is &lt;strong>&lt;a class="link" href="https://www.gnu.org/software/make/" target="_blank" rel="noopener"
>Make&lt;/a>&lt;/strong> as a &lt;strong>companion&lt;/strong> for my Shell scripts.&lt;/p>
&lt;h2 id="-make-vs--shell-in-a--nutshell">🏗 Make vs. 🐚 Shell in a 🥜 Nutshell
&lt;/h2>&lt;ul>
&lt;li>Purpose: Make is good at &lt;strong>creating files&lt;/strong>, Shell is good at &lt;strong>executing scripts&lt;/strong>.&lt;/li>
&lt;li>Portability: If your system has Bash, chances are pretty high that Make is also available.&lt;/li>
&lt;li>Developer API: Make has a &lt;strong>clear entrypoint&lt;/strong> (namely &lt;code>make&lt;/code>), Shell can be everything you want it to be.&lt;/li>
&lt;/ul>
&lt;p>Make is a tool that has its origin in the world of compiled languages, especially C.
Compiling source code into binary artifacts (and doing so 🏎 &lt;em>economically&lt;/em>) is what Make was originally designed for.
I mean, the name of a tool should make its use clear, but let me just state this again for my future self:
Make is meant to 🏗 make (create) files.&lt;/p>
&lt;p>&lt;strong>It&amp;rsquo;s all about target files.&lt;/strong>
That&amp;rsquo;s why it makes sense to approach a Makefile with a mindset of &amp;ldquo;What do I want to create/build?&amp;rdquo; instead of &amp;ldquo;What do I want to perform?&amp;rdquo;
To me this sounds very reminiscent of the distinction between &lt;em>declarative and imperative&lt;/em> programming.&lt;/p>
&lt;h2 id="safely-versioned-secrets-management">Safely Versioned Secrets Management
&lt;/h2>&lt;p>My concrete entrypoint into Make was the following use case I had lately, and it hopefully helps to illustrate the point of target files:&lt;/p>
&lt;ul>
&lt;li>☸️ You have 2 AWS accounts with 1 &lt;strong>Kubernetes&lt;/strong> cluster each.
(One is for running a dev and a staging environment, the other one is running the production environment.)&lt;/li>
&lt;li>🔑 Secrets are stored in AWS &lt;strong>Secrets Manager&lt;/strong> and synced into the cluster via &lt;a class="link" href="https://github.com/external-secrets/kubernetes-external-secrets" target="_blank" rel="noopener"
>ExternalSecrets&lt;/a>.&lt;/li>
&lt;li>⛔️ You are &lt;strong>not allowed&lt;/strong> to store secrets in Git, not even in encrypted form.&lt;/li>
&lt;li>🪣 The secrets are JSON files and the &lt;strong>key names&lt;/strong> are important, so you want to store them in Git.&lt;/li>
&lt;/ul>
&lt;p>What I did as a first step was to create sample secrets files that contained the keys but no valid data (kind of the &lt;em>schema&lt;/em> of the secrets):&lt;/p>
&lt;pre tabindex="0">&lt;code>secrets
├── dev # One directory per target environment
│   └── .keep
├── staging
│   └── .keep
├── prod
│   └── .keep
├── config1.sample.json # One sample file per secret
├── service2.sample.json
└── service3.sample.json
&lt;/code>&lt;/pre>&lt;p>I put the keys I needed into the sample files and as a value a description of what to put in (or e.g. from which Password Service to fetch the value from).
The file &lt;code>service2.sample.json&lt;/code> would e.g. look like this.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;EXTERNAL_API_KEY&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;API Key of EXTERNAL_SERVICE&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;CLOUD_SERVICE_CLIENT_SECRET&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;client secret for accessing CLOUD_SERVICE&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;CLOUD_SERVICE_PASSWORD&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;password for accessing CLOUD_SERVICE&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;BASIC_AUTH_PASSWORD&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;password for sending via Basic Auth&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The target structure I wanted to achieve was this:&lt;/p>
&lt;pre tabindex="0">&lt;code>secrets
├── dev
│   ├── config1.json # This file contains the *keys* of
│ │ # secrets/config1.sample.json
│ │ # and the actual secret *values*!
│   ├── service2.json
│   ├── service3.json
│   └── .keep
├── staging
│   ├── config1.json # Contains key of sample file and
│ │ # values for staging environment.
│   ├── service2.json
│   ├── service3.json
│   └── .keep
├── prod
│   ├── config1.json
│   ├── service2.json
│   ├── service3.json
│   └── .keep
├── config1.sample.json
├── service2.sample.json
└── service3.sample.json
&lt;/code>&lt;/pre>&lt;p>In order to not commit any actual secrets into version control, I added the following entries to my &lt;strong>.gitignore&lt;/strong>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Ignore secret data ...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">secrets/**/*.json
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># ... but keep the samples&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">!secrets/*.sample.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="copying-the-samples">Copying the Samples
&lt;/h3>&lt;p>Now how do you copy the files to all environment&amp;rsquo;s directories?
And how do you make sure you copy them &lt;em>exactly once&lt;/em> (so you don&amp;rsquo;t lose the secrets you already entered)?&lt;/p>
&lt;p>You could create a script with the following logic:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># For each environment directory:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## For each sample file:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">### Extract the service name&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">### Check if target secret file already exists&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">### If not, copy sample to target file&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>But now, 🏗 Make to the rescue:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-make" data-lang="make">&lt;span class="line">&lt;span class="cl">&lt;span class="c">### Variables
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Fetch all sample files.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nv">secrets_samples&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">$(&lt;/span>wildcard secrets/*.sample.json&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Construct the paths for all dev secrets destinations.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nv">dev_secrets&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">$(&lt;/span>patsubst secrets/%.sample.json,secrets/dev/%.json,&lt;span class="k">$(&lt;/span>secrets_samples&lt;span class="k">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Construct the paths for all staging secrets destinations.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nv">staging_secrets&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">$(&lt;/span>patsubst secrets/dev/%,secrets/staging/%,&lt;span class="k">$(&lt;/span>dev_secrets&lt;span class="k">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Construct the paths for all staging secrets destinations.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nv">prod_secrets&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">$(&lt;/span>patsubst secrets/dev/%,secrets/prod/%,&lt;span class="k">$(&lt;/span>dev_secrets&lt;span class="k">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Gather the paths of all secrets&amp;#39; destinations.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nv">all_secrets&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">$(&lt;/span>dev_secrets&lt;span class="k">)&lt;/span> &lt;span class="k">$(&lt;/span>staging_secrets&lt;span class="k">)&lt;/span> &lt;span class="k">$(&lt;/span>prod_secrets&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">### Rules
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 🎯 Purpose: &amp;#34;Copy all samples to their destinations.&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 🤓 What Make sees: &amp;#34;When you build the file secrets.copy-templates,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># make sure that all files in $(all_secrets) have been built first.&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 👩‍🏫 Explanation: A rule can be empty, and a rule can have prerequisites
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># on the first line. I like to think of such a rule as a kind of shortcut.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nf">secrets.copy-templates&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">$(&lt;/span>&lt;span class="nv">all_secrets&lt;/span>&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 🎯 Purpose: &amp;#34;Ensure that Make still runs the job &amp;#39;secrets.copy-templates&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># even if a file called &amp;#39;secrets.copy-templates&amp;#39; is created.&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 🤓 What Make sees: &amp;#34;I am supposed to always build secrets.copy-templates
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># even if that file already exists.&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nf">.PHONY&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">secrets&lt;/span>.&lt;span class="n">copy&lt;/span>-&lt;span class="n">templates&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 🎯 Purpose: &amp;#34;Copy the file on the right to the file on the left.&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 🤓 What Make sees: &amp;#34;When a file matching the pattern secrets/dev/(.*).json
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># is built, execute this rule.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Also first make sure that the corresponding file secrets/$1.sample.json
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># has been built before.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># And the rule is: Copy the source file on the right ($&amp;lt;) to the destination
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># file on the left ($@).&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 👩‍🏫 Explanation: These 3 rules are applied when you call secrets.copy-templates
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># because it requires $(all_secrets) to be built.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nf">secrets/dev/%.json&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">secrets&lt;/span>/%.&lt;span class="n">sample&lt;/span>.&lt;span class="n">json&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> cp $&amp;lt; &lt;span class="nv">$@&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">secrets/staging/%.json&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">secrets&lt;/span>/%.&lt;span class="n">sample&lt;/span>.&lt;span class="n">json&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> cp $&amp;lt; &lt;span class="nv">$@&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">secrets/prod/%.json&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">secrets&lt;/span>/%.&lt;span class="n">sample&lt;/span>.&lt;span class="n">json&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> cp $&amp;lt; &lt;span class="nv">$@&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If you now execute &lt;code>make secrets.copy-templates&lt;/code>, the sample files will be copied to all environment directories.
And if you run that same command again, 🙊 &lt;strong>Make will not copy anything&lt;/strong> because it intelligenty detected that the source files have not changed since the last execution.&lt;/p>
&lt;p>The code above is certainly not optimal - I bet you could abstract away the environment names with bit of metaprogramming, but let&amp;rsquo;s not optimize prematurely.
I think the result is already impressive, especially if you consider the following:&lt;/p>
&lt;ul>
&lt;li>☝️ You don&amp;rsquo;t even have to call the job explicitly to run it.
As long as &lt;code>secrets.copy-templates&lt;/code> is the first build defined in the Makefile, you can even execute just &lt;code>make&lt;/code> &lt;em>without any parameters&lt;/em>.&lt;/li>
&lt;li>👨‍💻 Onboarding a new colleague to your repository now sounds a lot more like:
&amp;ldquo;Yes, do read the README, but above all execute &lt;code>make&lt;/code>.&amp;rdquo;
&lt;ul>
&lt;li>⛑ This is especially true if your Makefile contains &lt;strong>&lt;a class="link" href="https://marmelab.com/blog/2016/02/29/auto-documented-makefile.html" target="_blank" rel="noopener"
>good help texts&lt;/a>&lt;/strong> for every rule.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="how-not-to-shoot-yourself-in-the-foot">How Not To Shoot Yourself in the Foot
&lt;/h4>&lt;p>Make was made primarily for building binaries from source code.
The fact that we are able to use it in the way described above comes with a warning:
If you do the following, you will lose the secret data you already entered into the secret files:&lt;/p>
&lt;ol>
&lt;li>Execute &lt;code>make secrets.copy-templates&lt;/code>.&lt;/li>
&lt;li>Edit a &lt;strong>sample file&lt;/strong>.&lt;/li>
&lt;li>Execute &lt;code>make secrets.copy-templates&lt;/code>.&lt;/li>
&lt;li>💥 Make will &lt;strong>copy and overwrite&lt;/strong> the edited sample file to all environment secret files.&lt;/li>
&lt;/ol>
&lt;p>Why?
Make compares timestamps, and when the source has a newer last-modified timestamp than the destination it will execute the rule&lt;/p>
&lt;p>Can we circumvent this?
We sure can.
You can either make sure that you edit each environment file after editing the sample file.
Or you change the last-modified timestamp &lt;strong>via a build&lt;/strong> in the Makefile 😉:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-make" data-lang="make">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">secrets.ensure-copy-once&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> f in &lt;span class="k">$(&lt;/span>all_secrets&lt;span class="k">)&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="o">[&lt;/span> -f &lt;span class="nv">$$&lt;/span>f &lt;span class="o">]&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> touch &lt;span class="nv">$$&lt;/span>f&lt;span class="p">;&lt;/span> &lt;span class="k">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now whenever you edit a sample file &lt;em>after the initial secrets.copy-templates&lt;/em> you run this build via &lt;code>make secrets.ensure-copy-once&lt;/code> and 🛡 your secrets will not be deleted.&lt;/p>
&lt;h3 id="extension-environment-specific-sample-files">Extension: Environment-specific Sample Files
&lt;/h3>&lt;p>One implicit assumption in my structure was that the secrets in service2 will always have the same schema &lt;strong>in every environment&lt;/strong>.
One day it so happened that service2 needed to have additional keys on prod, but they &lt;strong>should not be present&lt;/strong> on dev or staging.&lt;/p>
&lt;p>I adjusted my desired structure like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>secrets
├── dev
│   ├── config1.json
│   ├── service2.json # Contains keys from service2.sample.json
│   ├── service3.json
│   └── .keep
├── staging
│   ├── config1.json
│   ├── service2.json # Contains keys from service2.sample.json
│   ├── service3.json
│   └── .keep
├── prod
│   ├── config1.json
│   ├── service2.json # Contains keys from service2.sample.prod.json
│   ├── service3.json
│   └── .keep
├── config1.sample.json
├── service2.sample.json # Default sample file
├── service2.sample.prod.json # Prod-specific sample file
└── service3.sample.json
&lt;/code>&lt;/pre>&lt;p>And I wrote my first &lt;strong>Makefile function&lt;/strong>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-make" data-lang="make">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># A Make function can take in an arbitrary number of numbered parameters.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="err">define&lt;/span> &lt;span class="err">copy_template&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">cp&lt;/span> &lt;span class="k">$(&lt;/span>1&lt;span class="k">)&lt;/span> &lt;span class="k">$(&lt;/span>2&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">@&lt;/span>&lt;span class="c"># Check if there is a more environment-specific sample file
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span> &lt;span class="k">$(&lt;/span>&lt;span class="nb">eval&lt;/span> ENVIRONMENT :&lt;span class="o">=&lt;/span> &lt;span class="k">$(&lt;/span>shell &lt;span class="nb">echo&lt;/span> &lt;span class="k">$(&lt;/span>2&lt;span class="k">)&lt;/span> &lt;span class="p">|&lt;/span> sed -E &lt;span class="s1">&amp;#39;s#secrets/(.*)/.*#\1#&amp;#39;&lt;/span>&lt;span class="k">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">$(&lt;/span>&lt;span class="nb">eval&lt;/span> ENVIRONMENT_SAMPLE_FILE :&lt;span class="o">=&lt;/span> &lt;span class="k">$(&lt;/span>patsubst %.sample.json,%.sample.&lt;span class="k">$(&lt;/span>ENVIRONMENT&lt;span class="k">)&lt;/span>.json,&lt;span class="k">$(&lt;/span>1&lt;span class="k">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @# If environment-specific file exists, copy it to destination
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">[&lt;/span> -f &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>ENVIRONMENT_SAMPLE_FILE&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span> cp &lt;span class="k">$(&lt;/span>ENVIRONMENT_SAMPLE_FILE&lt;span class="k">)&lt;/span> &lt;span class="k">$(&lt;/span>2&lt;span class="k">)&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">endef&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Calling a Make function works by executing &amp;#39;call&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># with the function name and all its parameters as a list.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># My previous rules now became this:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nf">secrets/dev/%.json&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">secrets&lt;/span>/%.&lt;span class="n">sample&lt;/span>.&lt;span class="n">json&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">$(&lt;/span>call copy_template,$&amp;lt;,&lt;span class="nv">$@&lt;/span>&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">secrets/staging/%.json&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">secrets&lt;/span>/%.&lt;span class="n">sample&lt;/span>.&lt;span class="n">json&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">$(&lt;/span>call copy_template,$&amp;lt;,&lt;span class="nv">$@&lt;/span>&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">secrets/prod/%.json&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">secrets&lt;/span>/%.&lt;span class="n">sample&lt;/span>.&lt;span class="n">json&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">$(&lt;/span>call copy_template,$&amp;lt;,&lt;span class="nv">$@&lt;/span>&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="-perfect-symphony-calling-scripts-from-make">🍣 Perfect Symphony: Calling Scripts From Make
&lt;/h3>&lt;p>It&amp;rsquo;s all good and nice to have your secrets created, but how do you deploy them to AWS Secrets Manager?
Of course you write a thin wrapper around the wonderfully verbose AWS CLI:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#!/usr/bin/env bash
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="nb">set&lt;/span> -euo pipefail
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># set -x # DEBUG&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">secret_name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Use second argument or read stdin&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">secret_value&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">2&lt;/span>&lt;span class="k">:-$(&lt;/span>cat -&lt;span class="k">)&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$secret_value&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="c1"># DEBUG&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Create secret in idempotent way, avoid script from failing&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">set&lt;/span> +e
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">aws secretsmanager create-secret --name &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$secret_name&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="p">&amp;amp;&lt;/span>&amp;gt; /dev/null
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">set&lt;/span> -e
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Put secret value and output response to stdout&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">aws secretsmanager put-secret-value --secret-id &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$secret_name&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --secret-string &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$secret_value&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> cat
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In your terminal you would call it e.g. like this:&lt;br>
&lt;code>./helpers/deploy-secret.sh envs/dev/config1-secrets &amp;lt; secrets/dev/config1.json&lt;/code>&lt;/p>
&lt;p>Let&amp;rsquo;s make a generic rule in Make to execute this script:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-make" data-lang="make">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># The dependency on $(all_secrets) is to make sure that the secrets files exist
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># before deploying them.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nf">secret.deploy&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">$(&lt;/span>&lt;span class="nv">all_secrets&lt;/span>&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ./helpers/deploy-secret.sh &lt;span class="k">$(&lt;/span>name&lt;span class="k">)&lt;/span> &amp;lt; secrets/&lt;span class="k">$(&lt;/span>environment&lt;span class="k">)&lt;/span>/&lt;span class="k">$(&lt;/span>filename&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The call to the script that you executed above would become this:&lt;br>
&lt;code>make secret.deploy name=envs/dev/config1-secrets environment=dev filename=config1&lt;/code>&lt;/p>
&lt;p>As we have multiple services, let&amp;rsquo;s add one rule per service:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-make" data-lang="make">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># The secret values in this one are the same across all environments
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nf">secret.deploy.config1&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">$(&lt;/span>MAKE&lt;span class="k">)&lt;/span> secret.deploy &lt;span class="nv">name&lt;/span>&lt;span class="o">=&lt;/span>envs/config1-secrets &lt;span class="nv">filename&lt;/span>&lt;span class="o">=&lt;/span>config1.json
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># service2 has different secret values on the different environments
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nf">secret.deploy.service2&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">$(&lt;/span>MAKE&lt;span class="k">)&lt;/span> secret.deploy &lt;span class="nv">name&lt;/span>&lt;span class="o">=&lt;/span>envs/&lt;span class="k">$(&lt;/span>environment&lt;span class="k">)&lt;/span>/service2-secrets &lt;span class="nv">filename&lt;/span>&lt;span class="o">=&lt;/span>service2.json
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># service 3 also has environment-specific secret values
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nf">secret.deploy.service3&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">$(&lt;/span>MAKE&lt;span class="k">)&lt;/span> secret.deploy &lt;span class="nv">name&lt;/span>&lt;span class="o">=&lt;/span>envs/&lt;span class="k">$(&lt;/span>environment&lt;span class="k">)&lt;/span>/service3-secrets &lt;span class="nv">filename&lt;/span>&lt;span class="o">=&lt;/span>service3.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we can tie these together into one rule for a whole environment:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-make" data-lang="make">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Deploy all secrets for one environment
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nf">secrets.deploy.all&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">$(&lt;/span>MAKE&lt;span class="k">)&lt;/span> secret.deploy.config1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">$(&lt;/span>MAKE&lt;span class="k">)&lt;/span> secret.deploy.service2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">$(&lt;/span>MAKE&lt;span class="k">)&lt;/span> secret.deploy.service3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Deploy all secrets for the dev cluster
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nf">secrets.deploy.dev&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">$(&lt;/span>MAKE&lt;span class="k">)&lt;/span> secrets.deploy.all &lt;span class="nv">environment&lt;/span>&lt;span class="o">=&lt;/span>dev
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">$(&lt;/span>MAKE&lt;span class="k">)&lt;/span> secrets.deploy.all &lt;span class="nv">environment&lt;/span>&lt;span class="o">=&lt;/span>staging
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Deploy all secrets for the prod cluster
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="nf">secrets.deploy.prod&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">$(&lt;/span>MAKE&lt;span class="k">)&lt;/span> secrets.deploy.all &lt;span class="nv">environment&lt;/span>&lt;span class="o">=&lt;/span>prod
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>✅ Once you are authenticated to the corresponding AWS account, you can deploy your secrets with either &lt;code>make secrets.deploy.dev&lt;/code> or &lt;code>make secrets.deploy.prod&lt;/code>.&lt;/p>
&lt;h2 id="summarizing">Summarizing
&lt;/h2>&lt;ul>
&lt;li>Make gives you a consistent and clean Developer API.&lt;/li>
&lt;li>Make is almost universally installed everywhere.&lt;/li>
&lt;li>Don&amp;rsquo;t decide between either Make &lt;strong>or&lt;/strong> Shell - use both together.
Refactor more complex logic into separate Shell scripts (like isolated functions) which are called from within Make.&lt;/li>
&lt;/ul>
&lt;p>You can check out the entire Makefile (including the secrets structure and scripts) in this &lt;a class="link" href="https://github.com/jscheytt/jscheytt.github.io.hugo/tree/main/content/post/story-first-makefile" target="_blank" rel="noopener"
>Git repo&lt;/a>.&lt;/p>
&lt;h2 id="credits">Credits
&lt;/h2>&lt;p>I am indebted to the following parties in making my start into the world of Make a lot smoother than I expected:&lt;/p>
&lt;ul>
&lt;li>Isaac Z. Schlueter for his &lt;a class="link" href="https://gist.github.com/isaacs/62a2d1825d04437c6f08" target="_blank" rel="noopener"
>interactive Gist&lt;/a>&lt;/li>
&lt;li>The guys at &lt;a class="link" href="https://www.upbound.io/" target="_blank" rel="noopener"
>Upbound&lt;/a> for creating &lt;a class="link" href="https://crossplane.io/" target="_blank" rel="noopener"
>Crossplane&lt;/a> where they use Make in &lt;a class="link" href="https://github.com/crossplane/provider-aws" target="_blank" rel="noopener"
>their providers&lt;/a> and even distribute &lt;a class="link" href="https://github.com/upbound/build" target="_blank" rel="noopener"
>common functionality&lt;/a> as a Git submodule&lt;/li>
&lt;/ul></description></item></channel></rss>